import { IEqualityComparer } from "./IEqualityComperer";

export interface IEnumerable<T = {}> {
    Aggregate(func: (working: T, next: T) => T): T;
    Aggregate<TResult>(func: (working: TResult, next: T, seed: T) => TResult): TResult;
    All(func: (item: T) => boolean): boolean;
    Any(): boolean;
    Any(func: (item: T) => boolean): boolean;
    Average(func: (item: T) => number): number;
    Concat(collection: IEnumerable<T> | Array<T>): IEnumerable<T>;
    Contains(item: T): boolean;
    Contains(item: T, equalityComparer: IEqualityComparer<T>): boolean;
    Count(): number;
    Count(func: (item: T) => boolean): number;
    Distinct(): IEnumerable<T>;
    Distinct(equalityComparer: IEqualityComparer<T>): IEnumerable<T>;
    ElementAt(index: number): T;
    ElementAtOrDefault(index: number): T;
    Except(collection: IEnumerable<T>): IEnumerable<T>;
    Except(collection: IEnumerable<T>, equalityComparer: IEqualityComparer<T>): IEnumerable<T>;
    First(): T;
    First(func: (item: T) => boolean): T;
    FirstOrDefault(): T;
    FirstOrDefault(func: (item: T) => boolean): T;
    GroupBy<TResult>(keys: IEnumerable<string> | Array<string>): IEnumerable<TResult>;
    GroupBy<TResult>(keys: IEnumerable<string> | Array<string>, equalityComparer: IEqualityComparer<T>): IEnumerable<TResult>;
    Intersect(collection: IEnumerable<T> | Array<T>): IEnumerable<T>;
    Intersect(collection: IEnumerable<T> | Array<T>, equalityComparer: IEqualityComparer<T>): IEnumerable<T>;
    Join(keys: IEnumerable<string> | Array<string>): IEnumerable<T>;
    Join(keys: IEnumerable<string> | Array<string>, equalityComparer: IEqualityComparer<T>): IEnumerable<T>;
    Last(): T;
    Last(func: (item: T) => boolean): T;
    LastOrDefault(): T;
    LastOrDefault(func: (item: T) => boolean): T;
    Max(): number;
    Max(func: (item: T) => number): number;
    Min(): number;
    Min(func: (item: T) => number): number;
    OfType(type: Function): IEnumerable<T>;
    OrderBy(): IEnumerable<T>;
    OrderBy(func: (item: T) => any): IEnumerable<T>;
    Reverse(): IEnumerable<T>;
    Select<TResult>(func: (item: T) => TResult): IEnumerable<TResult>;
    Equals(collection: IEnumerable<T>): boolean;
    Equals(collection: IEnumerable<T>, equalityComparer: IEqualityComparer<T>): boolean;
    Single(): T;
    SingleOrDefault(): T;
    Skip(count: number): IEnumerable<T>;
    SkipWhile(func: (item: T) => boolean): IEnumerable<T>;
    Sum(): number;
    Sum(func: (item: T) => number): number;
    Take(count: number): IEnumerable<T>;
    TakeWhile(func: (item: T) => boolean): IEnumerable<T>;
    Union(collection: IEnumerable<T>): IEnumerable<T>;
    Union(collection: IEnumerable<T>, equalityComparer: IEqualityComparer<T>): IEnumerable<T>;
    Where(func: (item: T) => boolean): IEnumerable<T>;
    Where(func: (item: T, index: number) => boolean): IEnumerable<T>;
    Zip<TCollection, TResult>(collection: IEnumerable<TCollection>, func: (itemA: T, itemB: TCollection) => TResult): TResult;
}